
# Junior Developer – Take-Home Exercise

## Purpose

This exercise aims to help us understand how you think, reason, and communicate. It is not about speed or perfect code.

## Instructions

* Read everything carefully
* Follow the rules exactly
* Do not add extra features
* When something is unclear, explain your assumption

**Please send back:**

1. Your code
2. Your answers to all questions below

---

## Part 1 – Coding Task

**Function Implementation:** `calculateFinalPrice(basePrice, countryCode, isFirstOrder)`

```go
func calculateFinalPrice(basePrice float64, countryCode string, isFirstOrder bool) float64 {
	price := basePrice

	if countryCode == "TH" {
		price += price * 0.07
	} else if countryCode == "FR" {
		price += price * 0.20
	}

	if isFirstOrder {
		price -= 100
	}

	if price < 0 {
		price = 0
	}

	return math.Round(price*100) / 100
}

```

---

## Part 2 – Code Review

*Assume the following code was generated by AI. Review it.*

### Questions

**List the issues (bugs or specification mismatches):**

* **First:** Missing datatype of parameter, in func it doesn't declare datatype of basePrice , countryCode and isFirstOrder. If not declared, type go will not know the type of parameter that is sent in the function and make an error.
* **Second:** The wrong declaration in go. It should use var or := in declarations instead of let. Otherwise, it won't be considered a declaration.
* **Third:** The equal operator it should use == to compare value not ===
* **Fourth:** The if condition in the picture it handles only if countryCode is “TH”or  not it doesn’t cover “FR” if countryCode be “other” It will add another 20%, which is incorrect.
* **Fifth:** In isFirstOrder condition in price -= price *0.1; it doesn’t subtract pure 100 it subtract price that include tax with additional 10%
* **Last:** When return price.toFixed i think in go it should use fmt.Sprintf("%.2f", num) and convert to float before return or use math.round

---

## Part 3 – Assumptions & Decisions

### Was anything unclear in the exercise?

**Yes.**

**What was unclear?**

1. First, the rules in they says round the result to 2 decimals it not tell round up or round down
2. Second, the base price type is unclear. It is not specified whether it should be an int or a float, as this depends on the business purpose and pricing rules.
3. Third, what if the base price is lower than 94 and this is first order. It will return 0 or something?

**What did you assume?**

* I assume finalPrice it should be round up when it greater than 5 and round down if below 5
* I assume the base price should be an integer.
* I assume when the base price is lower than 94 and this is first order. It will return 0

**Why?**

* Based on standard mathematical rounding, if the third decimal place is 5 or more, round up; if the third decimal place is less than 5, round down.
* Because prices are typically set as integers at the base level. However, this may vary depending on business requirements.
* Because when the base price is less than 94 and this is the first order, the function should return 0, since a negative price or discount would not make sense from a business perspective.

---

## Part 4 – Interfaces & Design

### Task

**Interface / Contract for the payment API:**

```go
type PaymentProvider interface {
    ProcessPayment(amount float64) (string, error)
}

```

**Test Cases (Pseudocode):**

1. **Test Timeout Failure:** Mock the `ProcessPayment` to return a "Timeout Error". Check if the caller handles the error without crashing.
2. **Test Status Code/Invalid Response:** Mock the API to return a 500 Internal Server Error. Check if the code correctly identifies the failure.
3. **Test Success Case:** Mock the API to return a 200 OK with a valid JSON transaction ID. Check if the JSON is decoded correctly.

### Explain

**Why does using an interface help testing?**
I think it helps because it helps me to control the responses and dependencies of methods. By using an interface, I can inject a mock service or other instead of the real one. For example, I can mock responses like success, timeout, or internal error which are hard to happen with a real service.

**One downside of using interfaces?**
idk, is it hard to implement?

**For each test:**

* **What does it check?** I separate the test into two scenarios: fail case and success case. In the failure case, I check if the external API times out or returns an error. The method should return the result that I expect. Second is to handle status code when returned from the external API. And for the success case, I check that when the API returns 200 OK, the JSON body can be decoded without any problem.
* **Why is it important?** It helps handle errors that can happen in this flow. If we don’t have these unit tests, problems like timeouts or API errors may not be detected until the system is running or otherwise found. These unit tests will check how the code reacts to these errors and make sure it returns the correct result instead of crashing.

---

## Part 5 – Theory: OOP vs Functional Programming

In my understanding, OOP is a way of looking at code in terms of classes and objects, while Functional is a way of looking at code in terms of functions. I prefer OOP over Functional because I'm more familiar with it.

---

## Part 6 – AI Usage

**Did you use AI?** Yes

**What did AI help with?**

* I used AI help in Part 4 , to help me set up ginkgo and mockgen because I have some issues when setting up these but method and structure and test case i think it my myself.
* I used AI to help check and wording , grammar and passages, making them clear and better structured, while keeping my own word , language and writing style.

**What did you verify yourself?**
I verified the structure, implementation , test case and test results myself.

**One example where AI can be wrong?**
AI can hallucinate, such as generating incorrect assumptions, or explanations that look convincing but are not actually correct.

---

**What do you do first?**

First, I will apologize for the issue. Then, I will identify when and where it occurs and determine which API is involved. After I can locating the API that have problem, I will trace it by check the request and response to understand which field or value is incorrect, and compare it with the expected correct one. Once I understand the expected behavior, I will check the functions and logic to find the root cause and determine the correct output. After that, I will create a new branch to fix this issue and then write unit tests to cover this case to ensure the same mistake does not happen again. After testing the API or function manually and confirming it works correctly, then open MR to request code review and Merge it back into the main branch.

---
